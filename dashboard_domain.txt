=== ./dashboard/components/ItemModal.jsx ===
ï»¿// Usar el alias @ para garantizar resoluciÃƒÂ³n correcta en Docker
import Modal from '@shared/components/Modal'
import UserForm from '../user-service/UserForm.jsx'
import ReservationForm from '../reservation-service/ReservationForm.jsx'
import FinanceForm from '../finance-service/FinanceForm.jsx'
import PackageForm from '../catalog-service/paquete-service/PackageForm.jsx'
import ExtraForm from '../catalog-service/extra-service/ExtraForm.jsx'
import OpcionAlimentoForm from '../catalog-service/alimento-service/OpcionAlimentoForm.jsx'
import TematicaForm from '../catalog-service/tematica-service/TematicaForm.jsx'
import MamparaForm from '../catalog-service/mampara-service/MamparaForm.jsx'
import PaymentForm from '../payment-service/PaymentForm.jsx'

const ItemModal = ({
  isOpen,
  onClose,
  title,
  loading,
  activeTab,
  handleSubmit,
  editingItem,
  generatedPassword,
  generateRandomPassword,
  users,
  packages,
  reservations,
  categories,
  onAddCategory,
  foodOptions,
  extras,
  tematicas,
  mamparas,
  payments,
  currentUser
}) => {
  const commonProps = {
    editingItem,
    onSave: handleSubmit,
    activeTab,
    payment: editingItem,
    onClose,
    users,
    packages,
    foodOptions,
    currentUser,
    extras,
    tematicas,
    mamparas,
    payments,
    reservations,
    blockedDates: reservations
      .filter(r => r.estado === 'confirmada')
      .map(r => new Date(r.fecha_reserva)),
    existingReservations: reservations
  }

  const renderForm = () => {
    switch (activeTab) {
      case 'users':
        return (
          <UserForm
            {...commonProps}
            generatedPassword={generatedPassword}
            generateRandomPassword={generateRandomPassword}
          />
        )

      case 'reservations':
        console.log('Abriendo formulario de reserva con los siguientes props:', commonProps)
        return <ReservationForm {...commonProps} />

      case 'finances':
        return (
          <FinanceForm
            {...commonProps}
            categories={categories}
            onAddCategory={onAddCategory}
            reservations={reservations}
          />
        )
      case 'packages':
        return <PackageForm {...commonProps} />
      case 'extras':
        return <ExtraForm {...commonProps} />
      case 'opcionesAlimento':
        return <OpcionAlimentoForm {...commonProps} />
      case 'tematicas':
        return <TematicaForm {...commonProps} />
      case 'mamparas':
        return <MamparaForm {...commonProps} />
      case 'payments':
        return <PaymentForm {...commonProps} payment={editingItem} />
      default:
        return null
    }
  }

  if (!isOpen) return null

  const footerContent = (
    <div className="flex justify-end">
      <button
        onClick={onClose}
        className="px-4 py-2 bg-gray-200 text-gray-800 rounded-md mr-2 hover:bg-gray-300 transition duration-150 ease-in-out"
      >
        Cancelar
      </button>
      <button
        form={`${activeTab}Form`}
        type="submit"
        className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition duration-150 ease-in-out"
        disabled={loading}
      >
        {loading ? 'Guardando...' : 'Guardar'}
      </button>
    </div>
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={title || `${editingItem ? 'Editar' : 'Agregar'} ${activeTab}`}
      footer={footerContent}
    >
      {renderForm()}
    </Modal>
  )
}

export default ItemModal

\n\n

=== ./dashboard/components/MonthSelector.jsx ===
import { useState, useEffect } from 'react';

const MonthSelector = ({ selectedMonth, setSelectedMonth, selectedYear, setSelectedYear }) => {
    const currentYear = new Date().getFullYear();
    const years = Array.from({ length: 5 }, (_, i) => currentYear - 2 + i);

    const months = [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
    ];

    return (
        <div className="mt-8 flex justify-end gap-4 items-center">
            <div className="flex gap-2 items-center">
                <select
                    value={selectedMonth}
                    onChange={(e) => setSelectedMonth(parseInt(e.target.value))}
                    className="bg-white border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                    {months.map((month, index) => (
                        <option key={index} value={index}>
                            {month}
                        </option>
                    ))}
                </select>
                <select
                    value={selectedYear}
                    onChange={(e) => setSelectedYear(parseInt(e.target.value))}
                    className="bg-white border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                    {years.map(year => (
                        <option key={year} value={year}>
                            {year}
                        </option>
                    ))}
                </select>
            </div>
            <div className="text-sm text-gray-600">
                {months[selectedMonth]} {selectedYear}
            </div>
        </div>
    );
};

export default MonthSelector;\n\n

=== ./dashboard/components/ReservationCalendar.jsx ===
ï»¿import { useState, useEffect } from 'react';
import Modal from '@shared/components/Modal';
import { Calendar, momentLocalizer } from 'react-big-calendar';
import moment from 'moment';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import { motion, AnimatePresence } from 'framer-motion';
import { FiChevronLeft, FiChevronRight, FiCalendar, FiX, FiInfo, FiCheck, FiAlertCircle } from 'react-icons/fi';
import axios from '@shared/components/axiosConfig';
import { toast } from 'react-hot-toast';

const localizer = momentLocalizer(moment);

const ReservationCalendar = ({ reservations }) => {
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [dateAvailability, setDateAvailability] = useState({});
  const [isBlockingMode, setIsBlockingMode] = useState(false);
  const [selectedDates, setSelectedDates] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [showLegend, setShowLegend] = useState(false);
  const [showBlockModal, setShowBlockModal] = useState(false);

  const checkDateAvailability = (date, reservations) => {
    const dateReservations = reservations.filter(
      r => r.fecha_reserva === date && r.estado !== 'cancelada'
    );

    const morningReserved = dateReservations.some(r => r.hora_inicio === '11:00:00');
    const eveningReserved = dateReservations.some(r => r.hora_inicio !== '11:00:00');

    if (morningReserved && eveningReserved) return 'unavailable';
    if (morningReserved || eveningReserved) return 'partial';
    return 'available';
  };

  useEffect(() => {
    const availability = {};
    const uniqueDates = [...new Set(reservations.map(r => r.fecha_reserva))];
    uniqueDates.forEach(date => {
      availability[date] = checkDateAvailability(date, reservations);
    });
    setDateAvailability(availability);
  }, [reservations]);

  const events = reservations.map(reservation => ({
    title: `#${reservation.id} ${reservation.usuario?.nombre || ''}`,
    start: new Date(reservation.fecha_reserva),
    end: new Date(reservation.fecha_reserva),
    allDay: true,
    resource: reservation,
  }));

  const eventStyleGetter = (event, start, end, isSelected) => {
    if (event.isBlockingPreview) {
      return {
        style: {
          backgroundColor: '#DC2626',
          borderRadius: '4px',
          opacity: 0.7,
          color: 'white',
          border: '2px dashed #991B1B',
          padding: '1px 4px',
          fontSize: '0.75rem'
        }
      };
    }

    const date = moment(start).format('YYYY-MM-DD');
    const availability = dateAvailability[date];
    let backgroundColor = '#4F46E5';
    
    if (availability === 'unavailable') {
      backgroundColor = '#EF4444';
    } else if (availability === 'partial') {
      backgroundColor = '#F59E0B';
    } else if (availability === 'available') {
      backgroundColor = '#10B981';
    }

    return {
      style: {
        backgroundColor: isSelected ? '#3730A3' : backgroundColor,
        borderRadius: '4px',
        opacity: 0.8,
        color: 'white',
        border: '0px',
        padding: '1px 4px',
        fontSize: '0.75rem'
      }
    };
  };

  const handleBlockDates = async () => {
    try {
      const response = await axios.post('/api/reservas/block-dates', {
        dates: selectedDates
      });
      
      if (response.status === 201) {
        // Toast con animaciÃƒÂ³n personalizada
        toast.custom(
          (t) => (
            <motion.div
              initial={{ opacity: 0, y: -40, scale: 0.6 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: 20, scale: 0.9 }}
              transition={{
                type: "spring",
                stiffness: 500,
                damping: 30,
                duration: 0.4
              }}
              className={`${
                t.visible ? 'animate-enter' : 'animate-leave'
              } max-w-md w-full bg-white shadow-lg rounded-lg pointer-events-auto flex ring-1 ring-black ring-opacity-5`}
            >
              <div className="flex-1 w-0 p-4">
                <div className="flex items-start">
                  <div className="flex-shrink-0 pt-0.5">
                    <div className="h-10 w-10 rounded-full bg-green-100 flex items-center justify-center">
                      <FiCheck className="h-6 w-6 text-green-600" />
                    </div>
                  </div>
                  <div className="ml-3 flex-1">
                    <p className="text-sm font-medium text-gray-900">
                      Ã‚Â¡DÃƒÂ­as bloqueados exitosamente!
                    </p>
                    <p className="mt-1 text-sm text-gray-500">
                      {selectedDates.length} {selectedDates.length === 1 ? 'dÃƒÂ­a administrativo' : 'dÃƒÂ­as administrativos'} bloqueado(s).
                    </p>
                  </div>
                </div>
              </div>
              <div className="flex border-l border-gray-200">
                <button
                  onClick={() => toast.dismiss(t.id)}
                  className="w-full border border-transparent rounded-none rounded-r-lg p-4 flex items-center justify-center text-sm font-medium text-indigo-600 hover:text-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  Cerrar
                </button>
              </div>
            </motion.div>
          ),
          { duration: 5000 }
        );
        
        setIsBlockingMode(false);
        setSelectedDates([]);
        
        // Emitir evento para actualizar reservas sin recargar la pÃƒÂ¡gina
        window.dispatchEvent(new CustomEvent('reservationsUpdated'));
        
        // Cerrar modal de bloqueo si estÃƒÂ¡ abierto
        setShowBlockModal(false);
      }
    } catch (error) {
      let errorMessage = 'Error al bloquear los dÃƒÂ­as';
      let invalidDatesText = '';
      
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
        if (error.response.data.invalidDates) {
          invalidDatesText = 'Fechas invÃƒÂ¡lidas: ' + error.response.data.invalidDates.join(', ');
        }
      }
      
      // Toast de error con animaciÃƒÂ³n
      toast.custom(
        (t) => (
          <motion.div
            initial={{ opacity: 0, y: -40, scale: 0.6 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 20, scale: 0.9 }}
            transition={{
              type: "spring",
              stiffness: 500,
              damping: 30,
              duration: 0.4
            }}
            className={`${
              t.visible ? 'animate-enter' : 'animate-leave'
            } max-w-md w-full bg-white shadow-lg rounded-lg pointer-events-auto flex ring-1 ring-black ring-opacity-5`}
          >
            <div className="flex-1 w-0 p-4">
              <div className="flex items-start">
                <div className="flex-shrink-0 pt-0.5">
                  <div className="h-10 w-10 rounded-full bg-red-100 flex items-center justify-center">
                    <FiAlertCircle className="h-6 w-6 text-red-600" />
                  </div>
                </div>
                <div className="ml-3 flex-1">
                  <p className="text-sm font-medium text-gray-900">
                    {errorMessage}
                  </p>
                  {invalidDatesText && (
                    <p className="mt-1 text-sm text-gray-500">
                      {invalidDatesText}
                    </p>
                  )}
                </div>
              </div>
            </div>
            <div className="flex border-l border-gray-200">
              <button
                onClick={() => toast.dismiss(t.id)}
                className="w-full border border-transparent rounded-none rounded-r-lg p-4 flex items-center justify-center text-sm font-medium text-indigo-600 hover:text-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                Cerrar
              </button>
            </div>
          </motion.div>
        ),
        { duration: 6000 }
      );
    }
  };

  const CustomToolbar = ({ date, onNavigate, label }) => (
    <div className="flex justify-between items-center px-2 py-1">
      <button
        onClick={() => onNavigate('PREV')}
        className="p-1 rounded-full hover:bg-indigo-100 transition-colors duration-200"
      >
        <FiChevronLeft className="text-indigo-600 text-lg" />
      </button>
      <span className="text-sm font-medium text-indigo-800">{label}</span>
      <div className="flex items-center gap-1">
        <button
          onClick={() => onNavigate('TODAY')}
          className="px-2 py-1 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-700 transition-colors duration-200 flex items-center gap-1"
        >
          <FiCalendar className="text-sm" /> Hoy
        </button>
        <button
          onClick={() => onNavigate('NEXT')}
          className="p-1 rounded-full hover:bg-indigo-100 transition-colors duration-200"
        >
          <FiChevronRight className="text-indigo-600 text-lg" />
        </button>
      </div>
    </div>
  );

  return (
    <div className="h-full">
      {/* Header con gradiente */}
      <div className="bg-gradient-to-r from-blue-600 to-indigo-700 px-6 py-4 rounded-t-xl">
        <div className="flex justify-between items-center">
          <h2 className="text-xl font-semibold text-white">Calendario de Reservas</h2>
          <div className="flex items-center gap-2">
            <button
              onClick={() => setShowLegend(!showLegend)}
              className="p-2 rounded-full hover:bg-white/20 transition-colors duration-200 text-white"
              title="Mostrar leyenda"
            >
              <FiInfo className="w-5 h-5" />
            </button>
            <button
              onClick={() => {
                setIsBlockingMode(!isBlockingMode);
                if (!isBlockingMode) {
                  setSelectedDates([]);
                }
              }}
              className={`px-3 py-1.5 rounded-full transition-all duration-300 flex items-center gap-2 text-sm ${
                isBlockingMode
                  ? 'bg-red-600 text-white hover:bg-red-700 shadow-md'
                  : 'bg-white/20 text-white hover:bg-white/30 backdrop-blur-sm'
              }`}
            >
              {isBlockingMode ? (
                <>
                  <FiX className="text-lg" />
                  <span>Cancelar</span>
                </>
              ) : (
                <>
                  <FiCalendar className="text-lg" />
                  <span>Bloquear</span>
                </>
              )}
            </button>
          </div>
        </div>
      </div>

      <div className="p-4 bg-white">
        {/* Calendario */}
        <div className={`relative ${isBlockingMode && selectedDates.length > 0 ? 'lg:w-3/4' : 'w-full'}`}>
          {/* Leyenda flotante */}
          <AnimatePresence>
            {showLegend && (
              <motion.div
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: -10 }}
                transition={{
                  duration: 0.2,
                  ease: "easeOut",
                  scale: {
                    type: "spring",
                    damping: 20,
                    stiffness: 300
                  }
                }}
                className="absolute top-2 right-2 z-10 bg-white/95 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-indigo-100 dark:bg-gray-800/95 dark:border-gray-700"
              >
                <div className="grid grid-cols-2 gap-2 text-xs">
                  <div className="flex items-center gap-1.5">
                    <div className="w-2.5 h-2.5 rounded bg-[#10B981]"></div>
                    <span>Disponible</span>
                  </div>
                  <div className="flex items-center gap-1.5">
                    <div className="w-2.5 h-2.5 rounded bg-[#F59E0B]"></div>
                    <span>Parcial</span>
                  </div>
                  <div className="flex items-center gap-1.5">
                    <div className="w-2.5 h-2.5 rounded bg-[#EF4444]"></div>
                    <span>Ocupado</span>
                  </div>
                  {isBlockingMode && (
                    <div className="flex items-center gap-1.5">
                      <div className="w-2.5 h-2.5 rounded bg-[#DC2626] border border-dashed border-[#991B1B]"></div>
                      <span>A bloquear</span>
                    </div>
                  )}
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* Calendario */}
          <div className="border border-indigo-100 rounded-lg shadow-sm overflow-hidden bg-white hover:shadow-md transition-shadow duration-300">
            <Calendar
              localizer={localizer}
              events={[
                ...events,
                ...selectedDates.map(date => ({
                  title: 'Bloquear',
                  start: new Date(date),
                  end: new Date(date),
                  allDay: true,
                  isBlockingPreview: true
                }))
              ]}
              startAccessor="start"
              endAccessor="end"
              views={['month']}
              eventPropGetter={eventStyleGetter}
              onSelectEvent={(event) => !isBlockingMode && setSelectedEvent(event.resource)}
              onSelectSlot={({ start, action }) => {
                if (!isBlockingMode) return;
                
                const date = new Date(start);
                date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
                const dateStr = moment(date).format('YYYY-MM-DD');
                
                // Verificar si la fecha es anterior a hoy
                const isPastDate = moment(date).isBefore(moment(), 'day');
                if (isPastDate) return; // No permitir seleccionar fechas pasadas
                
                if (action === 'click') {
                  setSelectedDates(prev => {
                    if (prev.includes(dateStr)) {
                      return prev.filter(d => d !== dateStr);
                    }
                    return [...prev, dateStr];
                  });
                } else if (action === 'select') {
                  if (!isDragging) {
                    setIsDragging(true);
                    setSelectedDates([dateStr]);
                  }
                }
              }}
              onSelecting={({ start, end }) => {
                if (!isBlockingMode || !isDragging) return;

                const dates = [];
                const startDate = new Date(start);
                const endDate = new Date(end);
                startDate.setMinutes(startDate.getMinutes() + startDate.getTimezoneOffset());
                endDate.setMinutes(endDate.getMinutes() + endDate.getTimezoneOffset());
                
                let current = moment(startDate);
                const endMoment = moment(endDate);
                const today = moment().startOf('day');

                while (current.isSameOrBefore(endMoment, 'day')) {
                  // Solo incluir fechas desde hoy en adelante
                  if (!current.isBefore(today)) {
                    dates.push(current.format('YYYY-MM-DD'));
                  }
                  current.add(1, 'days');
                }

                setSelectedDates(dates);
                return true;
              }}
              onSelectEnd={() => {
                setIsDragging(false);
              }}
              selectable={isBlockingMode}
              components={{
                toolbar: CustomToolbar,
              }}
              dayPropGetter={date => {
                const dateStr = moment(date).format('YYYY-MM-DD');
                const isSelected = selectedDates.includes(dateStr);
                const isPastDate = moment(date).isBefore(moment(), 'day');
                
                return {
                  className: `text-sm ${isSelected ? 'selected-date' : ''} ${isPastDate ? 'past-date' : ''}`,
                  style: {
                    margin: 0,
                    padding: '0.25rem',
                    backgroundColor: isPastDate 
                      ? 'rgba(229, 231, 235, 0.5)' 
                      : isSelected 
                        ? 'rgba(220, 38, 38, 0.1)' 
                        : 'transparent',
                    opacity: isPastDate ? 0.5 : 1,
                    cursor: isPastDate ? 'not-allowed' : 'pointer',
                    transition: 'background-color 0.2s ease, opacity 0.2s ease',
                    pointerEvents: isPastDate ? 'none' : 'auto'
                  }
                };
              }}
              style={{ height: 500 }}
            />
          </div>
        </div>

        {/* BotÃƒÂ³n flotante para seleccionar dÃƒÂ­as */}
        <AnimatePresence>
          {isBlockingMode && (
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
              className="fixed bottom-6 right-6 z-50"
            >
              <button
                onClick={() => setShowBlockModal(true)}
                className="bg-indigo-600 text-white px-5 py-3 rounded-full shadow-lg hover:bg-indigo-700 transition-all duration-300 flex items-center gap-2 hover:shadow-indigo-200 hover:shadow-md"
              >
                <FiCalendar className="text-lg" />
                <span>
                  {selectedDates.length === 0 
                    ? 'Seleccionar DÃƒÂ­as' 
                    : `${selectedDates.length} ${selectedDates.length === 1 ? 'dÃƒÂ­a' : 'dÃƒÂ­as'} seleccionados`}
                </span>
              </button>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Modal de bloqueo de fechas */}
        <Modal
          isOpen={showBlockModal}
          onClose={() => {
            setShowBlockModal(false);
            if (!selectedDates.length) {
              setIsBlockingMode(false);
            }
          }}
          title="Bloquear Fechas"
          maxWidth="sm"
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
            className="space-y-4"
          >
            <div className="bg-indigo-50 rounded-lg p-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="w-10 h-10 rounded-full bg-indigo-100 flex items-center justify-center">
                    <FiCalendar className="text-indigo-600 text-xl" />
                  </div>
                  <div>
                    <h4 className="text-sm font-medium text-indigo-900">SelecciÃƒÂ³n de DÃƒÂ­as</h4>
                    <p className="text-sm text-indigo-600">
                      Selecciona los dÃƒÂ­as que deseas bloquear
                    </p>
                  </div>
                </div>
                <p className="text-xs text-indigo-600">
                  Haz clic en el calendario para agregar mÃƒÂ¡s dÃƒÂ­as
                </p>
              </div>
            </div>

            <div className="border border-indigo-100 rounded-lg divide-y max-h-[300px] overflow-y-auto">
              <AnimatePresence mode="popLayout">
              {selectedDates
                .sort((a, b) => moment(a).diff(moment(b)))
                .map(date => (
                <motion.div
                  key={date}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  transition={{ 
                    duration: 0.2,
                    type: "spring",
                    stiffness: 500,
                    damping: 30
                  }}
                  className="px-4 py-2 flex justify-between items-center"
                >
                  <span className="text-sm text-gray-600">
                    {moment(date).format('LL')}
                  </span>
                  <button
                    onClick={() => setSelectedDates(prev => prev.filter(d => d !== date))}
                    className="text-red-500 hover:text-red-600 p-1 rounded-full hover:bg-red-50 transition-colors duration-200"
                  >
                    <FiX className="text-lg" />
                  </button>
                </motion.div>
              ))}
              </AnimatePresence>
            </div>

            <div className="flex flex-col gap-3 mt-6 sticky bottom-0 bg-white pt-4 border-t shadow-lg">
              <div className="w-full text-center text-sm text-gray-500 mb-3">
                {selectedDates.length} {selectedDates.length === 1 ? 'dÃƒÂ­a seleccionado' : 'dÃƒÂ­as seleccionados'}
              </div>
              <div className="flex gap-3 w-full">
                <button
                  onClick={() => {
                    setShowBlockModal(false);
                    setIsBlockingMode(false);
                    setSelectedDates([]);
                  }}
                  className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 transition-colors duration-200 text-sm font-medium"
                >
                  Cancelar
                </button>
                <button
                  onClick={handleBlockDates}
                  disabled={selectedDates.length === 0}
                  className={`flex-1 px-4 py-2 text-white rounded-md transition-colors duration-200 text-sm font-medium
                    ${selectedDates.length === 0 
                      ? 'bg-gray-400 cursor-not-allowed' 
                      : 'bg-indigo-600 hover:bg-indigo-700'}`}
                >
                  Confirmar Bloqueo
                </button>
              </div>
            </div>
          </motion.div>
        </Modal>

        {/* Modal de detalles de la reserva */}
        <Modal
          isOpen={!!selectedEvent}
          onClose={() => setSelectedEvent(null)}
          title="Detalles de la Reserva"
          maxWidth="lg"
        >
          {selectedEvent && (
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{
                duration: 0.3,
                ease: "easeOut",
                y: {
                  type: "spring",
                  damping: 25,
                  stiffness: 200
                }
              }}
              className="space-y-6"
            >
              {/* Estado de la reserva */}
              <div className="flex justify-end">
                <span className={`px-3 py-1.5 rounded-full text-sm font-medium ${
                  selectedEvent.estado === 'pendiente' ? 'bg-yellow-100 text-yellow-800' :
                  selectedEvent.estado === 'confirmada' ? 'bg-green-100 text-green-800' :
                  selectedEvent.estado === 'cancelada' ? 'bg-red-100 text-red-800' :
                  'bg-gray-100 text-gray-800'
                }`}>
                  {selectedEvent.estado.charAt(0).toUpperCase() + selectedEvent.estado.slice(1)}
                </span>
              </div>

              {/* InformaciÃƒÂ³n del Cliente */}
              <div className="flex items-start space-x-4 bg-white p-4 rounded-lg border border-indigo-100">
                <div className="w-12 h-12 rounded-full bg-indigo-100 flex items-center justify-center flex-shrink-0">
                  <span className="text-indigo-600 text-xl font-medium">
                    {(selectedEvent.usuario?.nombre || 'N')[0].toUpperCase()}
                  </span>
                </div>
                <div>
                  <h4 className="text-lg font-medium text-gray-900">
                    {selectedEvent.usuario?.nombre || 'No especificado'}
                  </h4>
                  <p className="text-sm text-gray-500">Cliente #{selectedEvent.id}</p>
                </div>
              </div>

              {/* Fecha y Hora */}
              <div className="bg-indigo-50 rounded-lg p-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <p className="text-sm text-indigo-600 font-medium mb-1">Fecha</p>
                    <p className="text-lg text-gray-900">{moment(selectedEvent.fecha_reserva).format('LL')}</p>
                  </div>
                  <div>
                    <p className="text-sm text-indigo-600 font-medium mb-1">Hora</p>
                    <p className="text-lg text-gray-900">{moment(selectedEvent.hora_inicio, 'HH:mm:ss').format('h:mm A')}</p>
                  </div>
                </div>
              </div>

              {/* Disponibilidad del DÃƒÂ­a */}
              <div className="border border-indigo-100 rounded-lg overflow-hidden">
                <div className="bg-indigo-50 px-3 py-2">
                  <h4 className="text-xs font-medium text-indigo-600">Disponibilidad del DÃƒÂ­a</h4>
                </div>
                <div className="divide-y divide-indigo-100">
                  <div className="px-3 py-2">
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-gray-600">MaÃƒÂ±ana</span>
                      <div className="flex items-center space-x-1">
                        <span className="text-xs text-gray-500">(11:00 - 16:00)</span>
                        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                          selectedEvent.hora_inicio === '11:00:00' 
                          ? 'bg-red-100 text-red-700' 
                          : 'bg-green-100 text-green-700'
                        }`}>
                          {selectedEvent.hora_inicio === '11:00:00' ? 'Ocupado' : 'Disponible'}
                        </span>
                      </div>
                    </div>
                  </div>
                  <div className="px-3 py-2">
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-gray-600">Tarde</span>
                      <div className="flex items-center space-x-1">
                        <span className="text-xs text-gray-500">(17:00 - 22:00)</span>
                        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                          selectedEvent.hora_inicio !== '11:00:00' 
                          ? 'bg-red-100 text-red-700' 
                          : 'bg-green-100 text-green-700'
                        }`}>
                          {selectedEvent.hora_inicio !== '11:00:00' ? 'Ocupado' : 'Disponible'}
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </motion.div>
          )}
        </Modal>
      </div>

      <style jsx="true" global="true">{`
        .rbc-day-bg.selected-date:hover {
          background-color: rgba(220, 38, 38, 0.2) !important;
        }
        .rbc-day-bg {
          transition: background-color 0.2s ease;
        }
        .rbc-calendar {
          font-size: 0.875rem;
        }
        .rbc-header {
          padding: 0.5rem 0;
          font-weight: 500;
          color: #4B5563;
        }
        .rbc-date-cell {
          padding: 0.25rem;
          font-size: 0.75rem;
        }
        .rbc-day-bg.past-date {
          background-color: rgba(229, 231, 235, 0.5) !important;
          cursor: not-allowed;
          opacity: 0.5;
        }
        .rbc-date-cell.past-date {
          color: #9CA3AF;
          opacity: 0.7;
        }
        .rbc-event {
          padding: 2px 4px !important;
          font-size: 0.75rem !important;
        }
        .rbc-toolbar button {
          font-size: 0.875rem;
          padding: 0.375rem 0.75rem;
        }
      `}</style>
    </div>
  );
};

export default ReservationCalendar;
\n\n

=== ./dashboard/components/ScreenSizeAlert.jsx ===
import { FiAlertCircle, FiX } from 'react-icons/fi';

const ScreenSizeAlert = ({ setShowAlert }) => (
    <div className="fixed top-0 left-0 right-0 bg-yellow-100 text-yellow-800 px-4 py-3 shadow-md z-50">
        <div className="flex items-center justify-between">
            <div className="flex items-center">
                <FiAlertCircle className="mr-2" />
                <p>
                    Para una mejor experiencia, se recomienda usar un iPad o dispositivo con pantalla mÃ¡s
                    grande.
                </p>
            </div>
            <button onClick={() => setShowAlert(false)} className="text-yellow-800 hover:text-yellow-900">
                <FiX size={24} />
            </button>
        </div>
    </div>
);

export default ScreenSizeAlert;\n\n

=== ./dashboard/components/TabNavigation.jsx ===
import React, { useState } from 'react';
import { FiChevronDown, FiPlus } from 'react-icons/fi';

const TabNavigation = ({ activeTab, setActiveTab, handleAddItem }) => {
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);

    const tabs = [
        { id: 'users', label: 'Usuarios' },
        { id: 'reservations', label: 'Reservas' },
        { id: 'finances', label: 'Finanzas' },
        { id: 'packages', label: 'Paquetes' },
        { id: 'extras', label: 'Extras' },
        { id: 'opcionesAlimento', label: 'Opc. Alimento' },
        { id: 'tematicas', label: 'TemÃ¡ticas' },
        { id: 'mamparas', label: 'Mamparas' },
        { id: 'payments', label: 'Pagos' },
        { id: 'galeria', label: 'GalerÃ­a' },
        { id: 'auditoria', label: 'Historial' },
        { id: 'archived', label: 'Archivados' },
    ];

    // Determinar si se debe mostrar el botÃ³n de agregar
    const showAddButton = !['auditoria', 'archived'].includes(activeTab);

    return (
        <div className="flex flex-col sm:flex-row justify-between items-center mb-4 space-y-4 sm:space-y-0">
            <div className="w-full sm:w-auto relative">
                {/* Dropdown para pantallas pequeÃ±as */}
                <div className="sm:hidden w-full">
                    <button
                        onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                        className="w-full flex justify-between items-center bg-gray-200 text-gray-700 py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                        {tabs.find(tab => tab.id === activeTab)?.label || 'Seleccionar'}
                        <FiChevronDown className={`ml-2 transform transition-transform duration-200 ${isDropdownOpen ? 'rotate-180' : ''}`} />
                    </button>
                    {isDropdownOpen && (
                        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg">
                            {tabs.map(({ id, label }) => (
                                <button
                                    key={id}
                                    onClick={() => {
                                        setActiveTab(id);
                                        setIsDropdownOpen(false);
                                    }}
                                    className={`w-full text-left py-2 px-4 hover:bg-gray-100 ${
                                        activeTab === id ? 'bg-blue-100 text-blue-700' : 'text-gray-700'
                                    }`}
                                >
                                    {label}
                                </button>
                            ))}
                        </div>
                    )}
                </div>

                {/* Tabs para pantallas medianas y grandes */}
                <div className="hidden sm:flex flex-wrap">
                    {tabs.map(({ id, label }) => (
                        <button
                            key={id}
                            onClick={() => setActiveTab(id)}
                            className={`mr-2 mb-2 py-2 px-4 rounded-lg transition-colors duration-200 ${
                                activeTab === id 
                                    ? 'bg-blue-500 text-white' 
                                    : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                            }`}
                        >
                            {label}
                        </button>
                    ))}
                </div>
            </div>
            {showAddButton && (
                <button
                    onClick={handleAddItem}
                    className="w-full sm:w-auto bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 flex items-center justify-center"
                >
                    <FiPlus className="mr-2" />
                    Agregar
                </button>
            )}
        </div>
    );
};

export default TabNavigation;\n\n

=== ./dashboard/components/index.js ===
ï»¿export { default as ItemModal } from './ItemModal';
export { default as MonthSelector } from './MonthSelector';
export { default as ReservationCalendar } from './ReservationCalendar';
export { default as ScreenSizeAlert } from './ScreenSizeAlert';
export { default as TabNavigation } from './TabNavigation';
\n\n

=== ./dashboard/index.js ===
export * from './components';
export * from './pages';
export * from './services';
\n\n

=== ./dashboard/pages/Dashboard.jsx ===
ï»¿import { useState, useEffect, useCallback, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { toast } from 'react-toastify'
// Asegurar que todas las importaciones usen el alias @ para resolver correctamente en Docker
import axiosInstance from '@/components/axiosConfig'
import { useAuth } from '@/hooks/useAuth'
import * as socketService from '@/services/socketService'
import CrmLayout from '@/components/layout/CrmLayout'
import { Breadcrumb } from '@shared/components'
// Importar tiendas Zustand
import {
  useUiStore,
  useUsersStore,
  useReservationsStore,
  useFinancesStore,
  usePackagesStore,
  useCategoriesStore,
  useThemesStore,
  useextrasService,
  useFoodOptionsStore,
  usemamparasService,
  usePaymentsStore
} from '@/store'
import ScreenSizeAlert from '@domains/dashboard/components/ScreenSizeAlert'
import UserSummary from './user-service/UserSummary.jsx'
import ReservationSummary from './reservation-service/ReservationSummary.jsx'
import FinancialSummary from './finance-service/FinancialSummary.jsx'
import UserTable from './user-service/UserTable.jsx'
import ReservationTable from './reservation-service/ReservationTable.jsx'
import FinanceTable from './finance-service/FinanceTable.jsx'
import PackageTable from './catalog-service/paquete-service/PackageTable.jsx'
import MonthSelector from '@domains/dashboard/components/MonthSelector'
import ReservationCalendar from '@domains/dashboard/components/ReservationCalendar'
import ReservationModal from './reservation-service/ReservationModal.jsx'
import ItemModal from '@domains/dashboard/components/ItemModal'
import FinanceDetailModal from './finance-service/FinanceDetailModal.jsx'
import UserForm from './user-service/UserForm.jsx'
import ReservationForm from './reservation-service/ReservationForm.jsx'
import FinanceForm from './finance-service/FinanceForm.jsx'
import PackageForm from './catalog-service/paquete-service/PackageForm.jsx'
import UserModal from './user-service/UserModal.jsx'
import ExtraForm from './catalog-service/extra-service/ExtraForm.jsx'
import ExtraTable from './catalog-service/extra-service/ExtraTable.jsx'
import OpcionAlimentoForm from './catalog-service/alimento-service/OpcionAlimentoForm.jsx'
import OpcionAlimentoTable from './catalog-service/alimento-service/OpcionAlimentoTable.jsx'
import TematicaForm from './catalog-service/tematica-service/TematicaForm.jsx'
import TematicaTable from './catalog-service/tematica-service/TematicaTable.jsx'
import Swal from 'sweetalert2'
import MonthlyReportModal from './finance-service/MonthlyReportModal.jsx'
import MamparaTable from './catalog-service/mampara-service/MamparaTable.jsx'
import 'react-big-calendar/lib/css/react-big-calendar.css'
import MamparaForm from './catalog-service/mampara-service/MamparaForm.jsx'
import PaymentTable from './payment-service/PaymentTable.jsx'
import PaymentForm from './payment-service/PaymentForm.jsx'
import PaymentModal from './payment-service/PaymentModal.jsx'
import PaymentDetails from './payment-service/PaymentDetails.jsx'
import AuditHistory from './auditory-service/AuditHistory.jsx'
import ArchivedTable from './auditory-service/ArchivedTable.jsx'
import GaleriaManagement from './gallery-service/GaleriaManagement.jsx'
import { HiPlus } from 'react-icons/hi'

const Dashboard = () => {
  const { user: currentUser } = useAuth();
  const navigate = useNavigate()
  
  // Estados de UI desde Zustand
  const { 
    activeTab, setActiveTab,
    isModalOpen, setIsModalOpen,
    isReservationModalOpen, setIsReservationModalOpen,
    isReportModalOpen, setIsReportModalOpen,
    isPaymentModalOpen, setIsPaymentModalOpen,
    isUserModalOpen, setIsUserModalOpen,
    loading, setLoading,
    isSmallScreen, setIsSmallScreen,
    showAlert, setShowAlert,
    userSearch, setUserSearch,
    reservationSearch, setReservationSearch,
    archivedSearch, setArchivedSearch,
    selectedMonth, setSelectedMonth,
    selectedYear, setSelectedYear,
    paymentModalMode, setPaymentModalMode,
    generatedPassword, generateRandomPassword
  } = useUiStore();

  // Estados de entidades (todavÃƒÂ­a mantenemos el estado local por ahora)
  const [users, setUsers] = useState([])
  const [reservations, setReservations] = useState([])
  const [finances, setFinances] = useState([])
  const [packages, setPackages] = useState([])
  const [categories, setCategories] = useState([])
  const [extras, setExtras] = useState([])
  const [tematicas, setTematicas] = useState([])
  const [archivedItems, setArchivedItems] = useState([]);
  const [editingItem, setEditingItem] = useState(null)
  const [selectedReservation, setSelectedReservation] = useState(null)
  const [selectedFinance, setSelectedFinance] = useState(null)
  const [mamparas, setMamparas] = useState([])
  const [foodOptions, setFoodOptions] = useState([])
  const [payments, setPayments] = useState([])
  const [selectedPayment, setSelectedPayment] = useState(null)
  const [selectedUser, setSelectedUser] = useState(null)
  
  // Determinar si mostrar el dashboard principal o contenido especÃƒÂ­fico
  const isMainDashboard = activeTab === 'dashboard';
  
  // Mapeo de categorÃƒÂ­as y sus pestaÃƒÂ±as para las migajas de pan
  const breadcrumbsMap = {
    dashboard: [{ label: 'Panel Principal', path: 'dashboard' }],
    users: [{ label: 'Usuarios', path: 'users' }],
    reservations: [{ label: 'Reservaciones', path: 'reservations' }],
    finances: [{ label: 'Finanzas', path: 'finances' }],
    payments: [{ label: 'Pagos', path: 'payments' }],
    packages: [{ label: 'CatÃƒÂ¡logo', path: 'catalog' }, { label: 'Paquetes', path: 'packages' }],
    extras: [{ label: 'CatÃƒÂ¡logo', path: 'catalog' }, { label: 'Extras', path: 'extras' }],
    opcionesAlimento: [{ label: 'CatÃƒÂ¡logo', path: 'catalog' }, { label: 'Opciones de Alimento', path: 'opcionesAlimento' }],
    tematicas: [{ label: 'CatÃƒÂ¡logo', path: 'catalog' }, { label: 'TemÃƒÂ¡ticas', path: 'tematicas' }],
    mamparas: [{ label: 'CatÃƒÂ¡logo', path: 'catalog' }, { label: 'Mamparas', path: 'mamparas' }],
    galeria: [{ label: 'Sistema', path: 'system' }, { label: 'GalerÃƒÂ­a', path: 'galeria' }],
    auditoria: [{ label: 'Sistema', path: 'system' }, { label: 'AuditorÃƒÂ­a', path: 'auditoria' }],
    archived: [{ label: 'Sistema', path: 'system' }, { label: 'Elementos Archivados', path: 'archived' }]
  };
  
  // Obtener los ÃƒÂ­tems del breadcrumb actual
  const currentBreadcrumbItems = useMemo(() => {
    return breadcrumbsMap[activeTab] || [];
  }, [activeTab]);
  
  // Manejar navegaciÃƒÂ³n desde el breadcrumb
  const handleBreadcrumbNavigation = useCallback((path) => {
    if (path === 'dashboard') {
      setActiveTab('dashboard');
    } else if (path === 'catalog') {
      setActiveTab('packages');
    } else if (path === 'system') {
      setActiveTab('galeria');
    } else if (breadcrumbsMap[path]) {
      setActiveTab(path);
    }
  }, [setActiveTab]);
  
  const handleViewUser = useCallback(user => {
    setSelectedUser(user)
    setIsUserModalOpen(true)
  }, [setIsUserModalOpen])

  const generateMonthlyReport = () => {
    setIsReportModalOpen(true)
  }

  const handleSelectReservation = reservation => {
    setSelectedReservation(reservation)
  }

  const handleCloseReservationModal = () => {
    setSelectedReservation(null)
  }

  // Obtener las funciones fetch de las tiendas
  const { fetchUsers: fetchUsersZustand } = useUsersStore();
  const { fetchReservations: fetchReservationsZustand, initSocketListeners } = useReservationsStore();
  const { fetchFinances: fetchFinancesZustand } = useFinancesStore();
  const { fetchPackages: fetchPackagesZustand } = usePackagesStore();
  const { fetchCategories: fetchCategoriesZustand } = useCategoriesStore();
  const { fetchExtras: fetchExtrasZustand } = useextrasService();
  const { fetchFoodOptions: fetchFoodOptionsZustand } = useFoodOptionsStore();
  const { fetchThemes: fetchThemesZustand } = useThemesStore();
  const { fetchMamparas: fetchMamparasZustand } = usemamparasService();
  const { fetchPayments: fetchPaymentsZustand } = usePaymentsStore();

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      // Usar Promise.allSettled para manejar errores individuales sin detener todo el proceso
      const results = await Promise.allSettled([
        fetchUsersZustand().then(data => setUsers(data)),
        fetchReservationsZustand().then(data => setReservations(data)),
        fetchFinancesZustand().then(data => setFinances(data)),
        fetchPackagesZustand().then(data => setPackages(data)),
        fetchCategoriesZustand().then(data => setCategories(data)),
        fetchExtrasZustand().then(data => setExtras(data)),
        fetchFoodOptionsZustand().then(data => setFoodOptions(data)),
        fetchThemesZustand().then(data => setTematicas(data)),
        fetchMamparasZustand().then(data => setMamparas(data)),
        fetchPaymentsZustand().then(data => setPayments(data)),
        // Obtener elementos archivados - todavÃƒÂ­a usando axios ya que no tenemos tiendas para estos
        axiosInstance.get('/reservas/archived'),
        axiosInstance.get('/pagos/archived'),
        axiosInstance.get('/finanzas/archived')
      ]);

      // Manejar elementos archivados
      const archivedData = [];
      if (results[10].status === 'fulfilled') {
        archivedData.push(...results[10].value.data.map(item => ({ ...item, type: 'reservas' })));
      }
      if (results[11].status === 'fulfilled') {
        archivedData.push(...results[11].value.data.map(item => ({ ...item, type: 'pagos' })));
      }
      if (results[12].status === 'fulfilled') {
        archivedData.push(...results[12].value.data.map(item => ({ ...item, type: 'finanzas' })));
      }
      setArchivedItems(archivedData);

      // Reportar errores
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          console.error(`Error en la solicitud ${index}:`, result.reason);
          
          // No mostrar toast para errores 404 en solicitudes de elementos archivados (ÃƒÂ­ndices 10, 11, 12)
          const isArchivedRequest = index >= 10 && index <= 12;
          const is404Error = result.reason?.response?.status === 404;
          
          if (!(isArchivedRequest && is404Error)) {
            toast.error(`Error al cargar los datos de la solicitud ${index + 1}`);
          }
        }
      });
    } catch (error) {
      console.error('Error al cargar los datos:', error);
      toast.error('Error al cargar los datos');
    } finally {
      setLoading(false);
    }
  }, [
    fetchUsersZustand, fetchReservationsZustand, fetchFinancesZustand, 
    fetchPackagesZustand, fetchCategoriesZustand, fetchExtrasZustand, 
    fetchFoodOptionsZustand, fetchThemesZustand, fetchMamparasZustand, 
    fetchPaymentsZustand, setLoading
  ]);

  useEffect(() => {
    // Inicializar datos y configurar Socket.IO
    fetchData().then(() => {
      // Usar la funciÃƒÂ³n initSocketListeners de reservationsStore para centralizar la lÃƒÂ³gica de sockets
      // Esta funciÃƒÂ³n se encarga de inicializar Socket.IO y configurar todos los listeners
      // TambiÃƒÂ©n actualiza automÃƒÂ¡ticamente el estado global de reservations en la tienda
      initSocketListeners({
        onReservaCreada: (nuevaReserva) => {
          console.log('Reserva creada recibida vÃƒÂ­a Socket.IO:', nuevaReserva);
          toast.success(`Nueva reserva #${nuevaReserva.id} creada`);
        },
        onReservaActualizada: (reservaActualizada) => {
          console.log('Reserva actualizada recibida vÃƒÂ­a Socket.IO:', reservaActualizada);
        },
        onReservaEliminada: (data) => {
          console.log('Reserva eliminada recibida vÃƒÂ­a Socket.IO:', data);
        },
        onFechasBloqueadas: (data) => {
          console.log('Fechas bloqueadas recibidas vÃƒÂ­a Socket.IO:', data);
          if (!data.reservas || !Array.isArray(data.reservas)) {
            // Si no tenemos datos completos de las reservas, recargar todo
            fetchData();
          }
        },
        onError: (error) => {
          console.error('Error en Socket.IO:', error);
          toast.error('Error en la comunicaciÃƒÂ³n en tiempo real');
        }
      });
    });

    // Limpieza al desmontar el componente
    return () => {
      // Desconectar y limpiar Socket.IO
      socketService.disconnect();
      // Limpiar listeners de Socket.IO
      useReservationsStore.getState().cleanupSocketListeners();
    };
  }, [fetchData, initSocketListeners]);

  const filteredUsers = useMemo(() => {
    return users.filter(
      user =>
        user.nombre.toLowerCase().includes(userSearch.toLowerCase()) ||
        user.email.toLowerCase().includes(userSearch.toLowerCase()) ||
        (user.id_personalizado &&
          user.id_personalizado
            .toLowerCase()
            .includes(userSearch.toLowerCase()))
    )
  }, [users, userSearch])

  const filteredReservations = useMemo(() => {
    return reservations.filter(
      reservation =>
        reservation.id.toString().includes(reservationSearch) ||
        (reservation.nombre_festejado &&
          reservation.nombre_festejado
            .toLowerCase()
            .includes(reservationSearch.toLowerCase()))
    )
  }, [reservations, reservationSearch])

  useEffect(() => {
    const checkScreenSize = () => {
      setIsSmallScreen(window.innerWidth < 768)
    }

    checkScreenSize()
    window.addEventListener('resize', checkScreenSize)

    return () => window.removeEventListener('resize', checkScreenSize)
  }, [])

  const handleViewReservation = useCallback(reservation => {
    setSelectedReservation(reservation)
    setIsReservationModalOpen(true)
  }, [])

  // FunciÃƒÂ³n para filtrar datos por mes
  const filterDataByMonth = useCallback(
    (data, dateField) => {
      // Primero verificar si data es un array
      if (!Array.isArray(data)) return [];
      
      // Filtrar por mes
      return data.filter(item => {
        // Verificar que el item y el campo de fecha existen
        if (!item || !item[dateField]) return false;
        
        // Convertir a objeto Date
        const itemDate = new Date(item[dateField]);
        
        // Asegurarse de que la fecha es vÃƒÂ¡lida
        if (isNaN(itemDate.getTime())) return false;
        
        // Comparar tanto mes como aÃƒÂ±o
        return itemDate.getMonth() === selectedMonth && 
               itemDate.getFullYear() === selectedYear;
      });
    },
    [selectedMonth, selectedYear]
  );

  const handleAddItem = useCallback(() => {
    if (activeTab === 'payments') {
      setSelectedPayment(null)
      setPaymentModalMode('add')
      setIsPaymentModalOpen(true)
    } else {
      setEditingItem(null)
      setIsModalOpen(true)
    }
  }, [activeTab])

  const handleSavePayment = useCallback(async (paymentData) => {
    try {
      await usePaymentsStore.getState().addPayment(paymentData);
      setIsPaymentModalOpen(false);
      fetchData();
    } catch (error) {
      console.error('Error al crear el pago:', error);
      toast.error('Error al crear el pago');
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData, setIsPaymentModalOpen])

  const handleEditItem = useCallback(
    item => {
      console.log('Editando elemento:', item)
      if (activeTab === 'payments') {
        setSelectedPayment(item)
        setPaymentModalMode('add')
        setIsPaymentModalOpen(true)
      } else {
        setEditingItem(item)
        setIsModalOpen(true)
      }
    },
    [activeTab]
  )
  
  const handleUpdatePaymentStatus = useCallback(async (paymentId, newStatus) => {
    try {
      await usePaymentsStore.getState().updatePaymentStatus(paymentId, newStatus);
      // Actualizar la UI con datos frescos
      await fetchData();
    } catch (error) {
      console.error('Error al actualizar el estado del pago:', error);
      toast.error('Error al actualizar el estado del pago');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData])

  const handleReservationStatusChange = useCallback(async (reservationId, newStatus) => {
    try {
      // Usar la tienda Zustand para actualizar el estado de la reserva
      await useReservationsStore.getState().updateReservationStatus(reservationId, newStatus);
      // No es necesario actualizar manualmente el estado local, ya que se actualizarÃƒÂ¡
      // automÃƒÂ¡ticamente desde la tienda al llamar a updateReservationStatus
      toast.success('Estado de la reserva actualizado con ÃƒÂ©xito');
    } catch (error) {
      console.error('Error al actualizar el estado de la reserva:', error);
      toast.error('Error al actualizar el estado de la reserva');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate])

  const handleSendEmail = useCallback(reservation => {
    toast.info(`Funcionalidad de enviar correo a ${reservation.usuario.email}`)
  }, [])

  const handleContactUser = useCallback(reservation => {
    toast.info(
      `Funcionalidad de contactar al usuario ${reservation.usuario.nombre}`
    )
  }, [])

  const handleError = useCallback(
    (error, action) => {
      if (error.response) {
        if (error.response.status === 404) {
          toast.warning('El elemento ya no existe')
        } else if (error.response.status === 401) {
          toast.error(
            'Tu sesiÃƒÂ³n ha expirado. Por favor, inicia sesiÃƒÂ³n nuevamente.'
          )
          navigate('/signin')
        } else {
          toast.error(
            `Error del servidor al ${action} el elemento: ${
              error.response.data.message || 'Algo saliÃƒÂ³ mal'
            }`
          )
        }
      } else if (error.request) {
        toast.error('No se recibiÃƒÂ³ respuesta del servidor')
      } else {
        toast.error(`Error al ${action} el elemento`)
      }
      console.error(`Error al ${action} el elemento:`, error)
    },
    [navigate]
  )

  function removeCircularReferences (obj, seen = new WeakSet()) {
    if (typeof obj !== 'object' || obj === null) {
      return obj
    }
    if (seen.has(obj)) {
      return '[Circular]'
    }
    seen.add(obj)
    const newObj = Array.isArray(obj) ? [] : {}
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = removeCircularReferences(obj[key], seen)
      }
    }
    return newObj
  }

  const handleSubmit = useCallback(
    async data => {
      setLoading(true)
      try {
        console.log('Datos recibidos en handleSubmit:', data)
        
        // Limpiar y validar los datos
        const cleanedData = removeCircularReferences(data)
        console.log('Datos limpios a enviar al servidor:', cleanedData)
        
        // Para reservas, validar y asegurar que id_usuario sea un nÃƒÂºmero
        if (activeTab === 'reservations' && !cleanedData.id_usuario) {
          toast.error('Debe seleccionar un usuario para la reserva')
          setLoading(false)
          return
        }
        
        if (activeTab === 'reservations') {
          cleanedData.id_usuario = Number(cleanedData.id_usuario)
        }
        
        // Usar las tiendas Zustand para crear/actualizar
        let result;
        
        if (editingItem) {
          // Actualizar usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().updateUser(editingItem.id, cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().updateReservation(editingItem.id, cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().updateFinance(editingItem.id, cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().updatePackage(editingItem.id, cleanedData);
              break;
            case 'extras':
              result = await useextrasService.getState().updateExtra(editingItem.id, cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().updateFoodOption(editingItem.id, cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().updateTheme(editingItem.id, cleanedData);
              break;
            case 'mamparas':
              result = await usemamparasService.getState().updateMampara(editingItem.id, cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().updatePayment(editingItem.id, cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        } else {
          // Crear usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().addUser(cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().addReservation(cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().addFinance(cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().addPackage(cleanedData);
              break;
            case 'extras':
              result = await useextrasService.getState().addExtra(cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().addFoodOption(cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().addTheme(cleanedData);
              break;
            case 'mamparas':
              result = await usemamparasService.getState().addMampara(cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().addPayment(cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        }
        
        setIsModalOpen(false);
        // Actualizar la UI con datos frescos
        await fetchData();
        
      } catch (error) {
        console.error('Error en handleSubmit:', error)
        if (error.response && error.response.status === 401) {
          toast.error(
            'Tu sesiÃƒÂ³n ha expirado. Por favor, inicia sesiÃƒÂ³n nuevamente.'
          )
          navigate('/signin')
          return
        } else {
          handleError(error, editingItem ? 'actualizar' : 'crear')
        }
      } finally {
        setLoading(false)
      }
    },
    [activeTab, editingItem, fetchData, handleError, navigate, setLoading, setIsModalOpen]
  )

  const handleDeleteItem = async (endpoint, id, successMessage) => {
    const result = await Swal.fire({
      title: 'Ã‚Â¿EstÃƒÂ¡s seguro?',
      text: 'Esta acciÃƒÂ³n desactivarÃƒÂ¡ el registro. PodrÃƒÂ¡s reactivarlo mÃƒÂ¡s tarde si es necesario.',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'SÃƒÂ­, desactivar',
      cancelButtonText: 'Cancelar'
    })

    if (result.isConfirmed) {
      try {
        // Determinar quÃƒÂ© tienda usar basado en el endpoint
        switch (endpoint) {
          case '/api/usuarios':
            await useUsersStore.getState().deleteUser(id);
            break;
          case '/api/reservas':
            await useReservationsStore.getState().deleteReservation(id);
            break;
          case '/api/finanzas':
            await useFinancesStore.getState().deleteFinance(id);
            break;
          case '/api/paquetes':
            await usePackagesStore.getState().deletePackage(id);
            break;
          case '/api/extras':
            await useextrasService.getState().deleteExtra(id);
            break;
          case '/api/opciones-alimentos':
            await useFoodOptionsStore.getState().deleteFoodOption(id);
            break;
          case '/api/tematicas':
            await useThemesStore.getState().deleteTheme(id);
            break;
          case '/api/mamparas':
            await usemamparasService.getState().deleteMampara(id);
            break;
          case '/api/pagos':
            await usePaymentsStore.getState().deletePayment(id);
            break;
          default:
            // Si no hay una tienda especÃƒÂ­fica para el endpoint, usar axios directamente
            await axiosInstance.delete(`${endpoint}/${id}`);
        }
        
        Swal.fire('Ã‚Â¡Desactivado!', successMessage, 'success');
        // Actualizar la UI con datos frescos
        await fetchData();
      } catch (error) {
        handleError(error, 'desactivar');
      }
    }
  }

  // Eliminada la funciÃƒÂ³n local generateRandomPassword ya que la estamos importando desde useUiStore

  const handleDownloadFile = useCallback(async (id, type) => {
    try {
      // Usar la tienda Zustand para descargar el archivo
      const blob = await useFinancesStore.getState().downloadFinanceFile(id, type);
      
      // Crear URL para el blob y descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `finanza_${id}_${type}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
      
      // Liberar la URL
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error al descargar el archivo:', error);
      toast.error('Error al descargar el archivo');
    }
  }, [])

  const handleViewDetails = useCallback(finance => {
    setSelectedFinance(finance)
  }, [])

  const handleAddCategory = useCallback(async newCategory => {
    try {
      await useCategoriesStore.getState().addCategory({
        nombre: newCategory.nombre,
        color: newCategory.color || '#000000'
      });
      // Actualizar categorÃƒÂ­as tras la adiciÃƒÂ³n
      const updatedCategories = await fetchCategoriesZustand();
      setCategories(updatedCategories);
      toast.success('CategorÃƒÂ­a aÃƒÂ±adida con ÃƒÂ©xito');
    } catch (error) {
      console.error('Error al aÃƒÂ±adir la categorÃƒÂ­a:', error);
      toast.error('Error al aÃƒÂ±adir la categorÃƒÂ­a');
    }
  }, [fetchCategoriesZustand])

  const renderModalContent = useCallback(() => {
    const props = {
      editingItem,
      onSave: handleSubmit,
      generateRandomPassword,
      generatedPassword,
      users,
      packages,
      categories,
      onAddCategory: handleAddCategory,
      reservations,
      tematicas,
      foodOptions,
      extras,
      currentUser
    }
    switch (activeTab) {
      case 'users':
        return <UserForm {...props} />
      case 'reservations':
        return <ReservationForm {...props} />
      case 'finances':
        return <FinanceForm {...props} />
      case 'packages':
        return <PackageForm {...props} />
      case 'extras':
        return <ExtraForm {...props} />
      case 'opcionesAlimento':
        return <OpcionAlimentoForm {...props} />
      case 'tematicas':
        return <TematicaForm {...props} />
      case 'mamparas':
        return <MamparaForm {...props} />
      case 'payments':
        return <PaymentForm {...props} />
      default:
        return null
    }
  }, [
    activeTab,
    editingItem,
    handleSubmit,
    generateRandomPassword,
    generatedPassword,
    users,
    packages,
    categories,
    handleAddCategory,
    reservations,
    tematicas,
    foodOptions,
    extras
  ])

  
  // Renderizar componente del panel segÃƒÂºn la categorÃƒÂ­a activa
  const renderDashboardWidgets = () => {
    if (!isMainDashboard) return null;
    
    return (
      <div className='mb-8'>
        {/* Header del Dashboard con gradiente */}
        <div className="bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl shadow-lg p-6 mb-8">
          <h1 className="text-3xl font-bold text-white mb-2">Panel de Control</h1>
          <p className="text-indigo-100">Bienvenido al sistema de administraciÃƒÂ³n de Tramboory</p>
        </div>
        
        {/* Widgets de estadÃƒÂ­sticas */}
        <div className='grid grid-cols-1 md:grid-cols-3 gap-6 mb-8'>
          <div className="bg-gradient-to-br from-indigo-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <UserSummary users={users} />
          </div>
          <div className="bg-gradient-to-br from-green-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-green-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <ReservationSummary
              reservations={reservations}
              filterDataByMonth={filterDataByMonth}
            />
          </div>
          <div className="bg-gradient-to-br from-purple-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-purple-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-2xl font-semibold text-gray-800">Pagos</h2>
                <div className="p-2 rounded-full bg-purple-100 text-purple-600">
                  <HiPlus className="w-5 h-5" />
                </div>
              </div>
              <p className="text-4xl font-bold text-purple-600">{payments.length}</p>
              <p className="text-sm text-gray-500 mt-1">
                {payments.filter(p => p.estado === 'completado').length} completados
              </p>
            </div>
          </div>
        </div>
        
        {/* Widgets principales */}
        <div className='grid grid-cols-1 lg:grid-cols-3 gap-6'>
          <div className="lg:col-span-2 bg-white rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-lg">
            <ReservationCalendar
              reservations={reservations}
              onSelectReservation={handleSelectReservation}
            />
          </div>
          <div className="bg-white rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-lg">
            <FinancialSummary
              finances={finances}
              filterDataByMonth={filterDataByMonth}
              categories={categories}
            />
          </div>
        </div>
      </div>
    );
  };
  
  // BotÃƒÂ³n de acciÃƒÂ³n contextual segÃƒÂºn la pestaÃƒÂ±a activa
  const renderActionButton = () => {
    // No mostrar botÃƒÂ³n en el dashboard principal
    if (isMainDashboard) return null;
    
    return (
      <div className="flex justify-end mb-4">
        <button
          onClick={handleAddItem}
          className="flex items-center px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors"
        >
          <HiPlus className="mr-2" />
          Agregar {getActiveTabLabel()}
        </button>
      </div>
    );
  };
  
  // Obtener nombre amigable para la pestaÃƒÂ±a activa
  const getActiveTabLabel = () => {
    switch (activeTab) {
      case 'users': return 'Usuario';
      case 'reservations': return 'ReservaciÃƒÂ³n';
      case 'finances': return 'Registro';
      case 'payments': return 'Pago';
      case 'packages': return 'Paquete';
      case 'extras': return 'Extra';
      case 'opcionesAlimento': return 'OpciÃƒÂ³n de Alimento';
      case 'tematicas': return 'TemÃƒÂ¡tica';
      case 'mamparas': return 'Mampara';
      case 'galeria': return 'Imagen';
      default: return 'Elemento';
    }
  };
  
  return (
    <CrmLayout>
      {isSmallScreen && showAlert && (
        <ScreenSizeAlert setShowAlert={setShowAlert} />
      )}
      
      {/* Widgets del dashboard principal, solo se muestran en la vista de dashboard */}
      {renderDashboardWidgets()}
      
      {/* Contenedor principal contextual */}
      <div className='bg-white rounded-xl shadow-md p-6 border border-gray-100'>
        {/* Breadcrumb para navegaciÃƒÂ³n contextual */}
        <Breadcrumb 
          items={currentBreadcrumbItems} 
          onNavigate={handleBreadcrumbNavigation}
        />
        
        {/* BotÃƒÂ³n de acciÃƒÂ³n contextual */}
        {renderActionButton()}
        {/* Contenido segÃƒÂºn pestaÃƒÂ±a activa */}
        {activeTab === 'users' && (
          <UserTable
            users={filteredUsers}
            userSearch={userSearch}
            setUserSearch={setUserSearch}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/usuarios',
                id,
                'Usuario desactivado con ÃƒÂ©xito',
                () => setIsModalOpen(false)
              )
            }
            handleViewUser={handleViewUser}
          />
        )}
        {activeTab === 'reservations' && (
          <ReservationTable
            reservations={filterDataByMonth(reservations, 'fecha_reserva')}
            reservationSearch={reservationSearch}
            setReservationSearch={setReservationSearch}
            handleViewReservation={handleViewReservation}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/reservas',
                id,
                'Reserva desactivada con ÃƒÂ©xito'
              )
            }
            selectedMonth={selectedMonth}
          />
        )}
        {activeTab === 'finances' && (
          <FinanceTable
            finances={filterDataByMonth(finances, 'fecha')}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/finanzas',
                id,
                'Finanza desactivada con ÃƒÂ©xito',
                () => setIsModalOpen(false)
              )
            }
            handleDownloadFile={handleDownloadFile}
            handleViewDetails={handleViewDetails}
            categories={categories}
            generateMonthlyReport={generateMonthlyReport}
          />
        )}
        {activeTab === 'packages' && (
          <PackageTable
            packages={packages}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/paquetes',
                id,
                'Paquete desactivado con ÃƒÂ©xito',
                () => setIsModalOpen(false),
                'paquetes'
              )
            }
          />
        )}
        {activeTab === 'extras' && (
          <ExtraTable
            extras={extras}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem('/api/extras', id, 'Extra eliminado con ÃƒÂ©xito')
            }
          />
        )}
        {activeTab === 'opcionesAlimento' && (
          <OpcionAlimentoTable
            opcionesAlimento={foodOptions}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/opciones-alimentos',
                id,
                'OpciÃƒÂ³n de alimento eliminada con ÃƒÂ©xito'
              )
            }
          />
        )}
        {activeTab === 'tematicas' && (
          <TematicaTable
            tematicas={tematicas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/tematicas',
                id,
                'TemÃƒÂ¡tica eliminada con ÃƒÂ©xito'
              )
            }
          />
        )}
        {activeTab === 'mamparas' && (
          <MamparaTable
            tematicas={tematicas}
            mamparas={mamparas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/mamparas',
                id,
                'Mampara eliminada con ÃƒÂ©xito'
              )
            }
          />
        )}
        {activeTab === 'payments' && (
          <PaymentTable
            payments={payments}
            reservations={reservations}
            onViewPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('view')
              setIsPaymentModalOpen(true)
            }}
            onEditPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('edit')
              setIsPaymentModalOpen(true)
            }}
          />
        )}
        {activeTab === 'auditoria' && (
          <AuditHistory />
        )}
        {activeTab === 'archived' && (
          <ArchivedTable
            items={archivedItems}
            itemSearch={archivedSearch}
            setItemSearch={setArchivedSearch}
            fetchData={fetchData}
            selectedMonth={selectedMonth}
            type="reservas"
          />
        )}
        {activeTab === 'galeria' && (
          <GaleriaManagement />
        )}
      </div>
      <MonthSelector
        selectedMonth={selectedMonth}
        setSelectedMonth={setSelectedMonth}
        selectedYear={selectedYear}
        setSelectedYear={setSelectedYear}
      />
      {isReservationModalOpen && selectedReservation && (
        <ReservationModal
          reservation={selectedReservation}
          onClose={handleCloseReservationModal}
          onStatusChange={newStatus =>
            handleReservationStatusChange(selectedReservation.id, newStatus)
          }
          onSendEmail={handleSendEmail}
          onContactUser={handleContactUser}
          tematicas={tematicas}
          extras={extras}
        />
      )}
      {isModalOpen && (
        <ItemModal
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          title={`${editingItem ? 'Editar' : 'Agregar'} ${activeTab.slice(
            0,
            -1
          )}`}
          loading={loading}
          activeTab={activeTab}
          handleSubmit={handleSubmit}
          editingItem={editingItem}
          generatedPassword={generatedPassword}
          generateRandomPassword={generateRandomPassword}
          users={users}
          packages={packages}
          reservations={reservations}
          categories={categories}
          onAddCategory={handleAddCategory}
          tematicas={tematicas}
          foodOptions={foodOptions}
          extras={extras}
          mamparas={mamparas}
          currentUser={currentUser}
        />
      )}
      {selectedFinance && (
        <FinanceDetailModal
          finance={selectedFinance}
          onClose={() => setSelectedFinance(null)}
          onDownloadFile={handleDownloadFile}
        />
      )}
      {isPaymentModalOpen && (
        <PaymentModal
          payment={selectedPayment}
          isOpen={isPaymentModalOpen}
          onClose={() => {
            setSelectedPayment(null)
            setIsPaymentModalOpen(false)
          }}
          onUpdateStatus={handleUpdatePaymentStatus}
          onSavePayment={handleSavePayment}
          reservations={reservations}
          mode={paymentModalMode}
        />
      )}
      {isUserModalOpen && selectedUser && (
        <UserModal
          user={selectedUser}
          reservations={reservations.filter(res => res.id_usuario === selectedUser.id)}
          onClose={() => {
            setSelectedUser(null)
            setIsUserModalOpen(false)
          }}
          onEdit={handleEditItem}
          onSendEmail={() => toast.info(`Funcionalidad de enviar correo a ${selectedUser.email}`)}
        />
      )}
      {isReportModalOpen && (
        <MonthlyReportModal
          isOpen={isReportModalOpen}
          onClose={() => setIsReportModalOpen(false)}
          finances={finances}
          categories={categories}
          selectedMonth={selectedMonth}
          selectedYear={selectedYear}
        />
      )}
    </CrmLayout>
  )
}

export default Dashboard

\n\n

=== ./dashboard/pages/Dashboard.jsx.backup.20250521220248 ===
import { useState, useEffect, useCallback, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { toast } from 'react-toastify'
// Asegurar que todas las importaciones usen el alias @ para resolver correctamente en Docker
import axiosInstance from '@/components/axiosConfig'
import { useAuth } from '@/hooks/useAuth'
import * as socketService from '@/services/socketService'
import CrmLayout from '@/components/layout/CrmLayout'
import { Breadcrumb } from '@/components/ui'
// Importar tiendas Zustand
import {
  useUiStore,
  useUsersStore,
  useReservationsStore,
  useFinancesStore,
  usePackagesStore,
  useCategoriesStore,
  useThemesStore,
  useExtrasStore,
  useFoodOptionsStore,
  useMamparasStore,
  usePaymentsStore
} from '@/store'
import ScreenSizeAlert from './dashboard-components/ScreenSizeAlert.jsx'
import UserSummary from './user-service/UserSummary.jsx'
import ReservationSummary from './reservation-service/ReservationSummary.jsx'
import FinancialSummary from './finance-service/FinancialSummary.jsx'
import UserTable from './user-service/UserTable.jsx'
import ReservationTable from './reservation-service/ReservationTable.jsx'
import FinanceTable from './finance-service/FinanceTable.jsx'
import PackageTable from './catalog-service/paquete-service/PackageTable.jsx'
import MonthSelector from './dashboard-components/MonthSelector.jsx'
import ReservationCalendar from './dashboard-components/ReservationCalendar.jsx'
import ReservationModal from './reservation-service/ReservationModal.jsx'
import ItemModal from './dashboard-components/ItemModal.jsx'
import FinanceDetailModal from './finance-service/FinanceDetailModal.jsx'
import UserForm from './user-service/UserForm.jsx'
import ReservationForm from './reservation-service/ReservationForm.jsx'
import FinanceForm from './finance-service/FinanceForm.jsx'
import PackageForm from './catalog-service/paquete-service/PackageForm.jsx'
import UserModal from './user-service/UserModal.jsx'
import ExtraForm from './catalog-service/extra-service/ExtraForm.jsx'
import ExtraTable from './catalog-service/extra-service/ExtraTable.jsx'
import OpcionAlimentoForm from './catalog-service/alimento-service/OpcionAlimentoForm.jsx'
import OpcionAlimentoTable from './catalog-service/alimento-service/OpcionAlimentoTable.jsx'
import TematicaForm from './catalog-service/tematica-service/TematicaForm.jsx'
import TematicaTable from './catalog-service/tematica-service/TematicaTable.jsx'
import Swal from 'sweetalert2'
import MonthlyReportModal from './finance-service/MonthlyReportModal.jsx'
import MamparaTable from './catalog-service/mampara-service/MamparaTable.jsx'
import 'react-big-calendar/lib/css/react-big-calendar.css'
import MamparaForm from './catalog-service/mampara-service/MamparaForm.jsx'
import PaymentTable from './payment-service/PaymentTable.jsx'
import PaymentForm from './payment-service/PaymentForm.jsx'
import PaymentModal from './payment-service/PaymentModal.jsx'
import PaymentDetails from './payment-service/PaymentDetails.jsx'
import AuditHistory from './auditory-service/AuditHistory.jsx'
import ArchivedTable from './auditory-service/ArchivedTable.jsx'
import GaleriaManagement from './gallery-service/GaleriaManagement.jsx'
import { HiPlus } from 'react-icons/hi'

const Dashboard = () => {
  const { user: currentUser } = useAuth();
  const navigate = useNavigate()
  
  // Estados de UI desde Zustand
  const { 
    activeTab, setActiveTab,
    isModalOpen, setIsModalOpen,
    isReservationModalOpen, setIsReservationModalOpen,
    isReportModalOpen, setIsReportModalOpen,
    isPaymentModalOpen, setIsPaymentModalOpen,
    isUserModalOpen, setIsUserModalOpen,
    loading, setLoading,
    isSmallScreen, setIsSmallScreen,
    showAlert, setShowAlert,
    userSearch, setUserSearch,
    reservationSearch, setReservationSearch,
    archivedSearch, setArchivedSearch,
    selectedMonth, setSelectedMonth,
    selectedYear, setSelectedYear,
    paymentModalMode, setPaymentModalMode,
    generatedPassword, generateRandomPassword
  } = useUiStore();

  // Estados de entidades (todavÃ­a mantenemos el estado local por ahora)
  const [users, setUsers] = useState([])
  const [reservations, setReservations] = useState([])
  const [finances, setFinances] = useState([])
  const [packages, setPackages] = useState([])
  const [categories, setCategories] = useState([])
  const [extras, setExtras] = useState([])
  const [tematicas, setTematicas] = useState([])
  const [archivedItems, setArchivedItems] = useState([]);
  const [editingItem, setEditingItem] = useState(null)
  const [selectedReservation, setSelectedReservation] = useState(null)
  const [selectedFinance, setSelectedFinance] = useState(null)
  const [mamparas, setMamparas] = useState([])
  const [foodOptions, setFoodOptions] = useState([])
  const [payments, setPayments] = useState([])
  const [selectedPayment, setSelectedPayment] = useState(null)
  const [selectedUser, setSelectedUser] = useState(null)
  
  // Determinar si mostrar el dashboard principal o contenido especÃ­fico
  const isMainDashboard = activeTab === 'dashboard';
  
  // Mapeo de categorÃ­as y sus pestaÃ±as para las migajas de pan
  const breadcrumbsMap = {
    dashboard: [{ label: 'Panel Principal', path: 'dashboard' }],
    users: [{ label: 'Usuarios', path: 'users' }],
    reservations: [{ label: 'Reservaciones', path: 'reservations' }],
    finances: [{ label: 'Finanzas', path: 'finances' }],
    payments: [{ label: 'Pagos', path: 'payments' }],
    packages: [{ label: 'CatÃ¡logo', path: 'catalog' }, { label: 'Paquetes', path: 'packages' }],
    extras: [{ label: 'CatÃ¡logo', path: 'catalog' }, { label: 'Extras', path: 'extras' }],
    opcionesAlimento: [{ label: 'CatÃ¡logo', path: 'catalog' }, { label: 'Opciones de Alimento', path: 'opcionesAlimento' }],
    tematicas: [{ label: 'CatÃ¡logo', path: 'catalog' }, { label: 'TemÃ¡ticas', path: 'tematicas' }],
    mamparas: [{ label: 'CatÃ¡logo', path: 'catalog' }, { label: 'Mamparas', path: 'mamparas' }],
    galeria: [{ label: 'Sistema', path: 'system' }, { label: 'GalerÃ­a', path: 'galeria' }],
    auditoria: [{ label: 'Sistema', path: 'system' }, { label: 'AuditorÃ­a', path: 'auditoria' }],
    archived: [{ label: 'Sistema', path: 'system' }, { label: 'Elementos Archivados', path: 'archived' }]
  };
  
  // Obtener los Ã­tems del breadcrumb actual
  const currentBreadcrumbItems = useMemo(() => {
    return breadcrumbsMap[activeTab] || [];
  }, [activeTab]);
  
  // Manejar navegaciÃ³n desde el breadcrumb
  const handleBreadcrumbNavigation = useCallback((path) => {
    if (path === 'dashboard') {
      setActiveTab('dashboard');
    } else if (path === 'catalog') {
      setActiveTab('packages');
    } else if (path === 'system') {
      setActiveTab('galeria');
    } else if (breadcrumbsMap[path]) {
      setActiveTab(path);
    }
  }, [setActiveTab]);
  
  const handleViewUser = useCallback(user => {
    setSelectedUser(user)
    setIsUserModalOpen(true)
  }, [setIsUserModalOpen])

  const generateMonthlyReport = () => {
    setIsReportModalOpen(true)
  }

  const handleSelectReservation = reservation => {
    setSelectedReservation(reservation)
  }

  const handleCloseReservationModal = () => {
    setSelectedReservation(null)
  }

  // Obtener las funciones fetch de las tiendas
  const { fetchUsers: fetchUsersZustand } = useUsersStore();
  const { fetchReservations: fetchReservationsZustand, initSocketListeners } = useReservationsStore();
  const { fetchFinances: fetchFinancesZustand } = useFinancesStore();
  const { fetchPackages: fetchPackagesZustand } = usePackagesStore();
  const { fetchCategories: fetchCategoriesZustand } = useCategoriesStore();
  const { fetchExtras: fetchExtrasZustand } = useExtrasStore();
  const { fetchFoodOptions: fetchFoodOptionsZustand } = useFoodOptionsStore();
  const { fetchThemes: fetchThemesZustand } = useThemesStore();
  const { fetchMamparas: fetchMamparasZustand } = useMamparasStore();
  const { fetchPayments: fetchPaymentsZustand } = usePaymentsStore();

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      // Usar Promise.allSettled para manejar errores individuales sin detener todo el proceso
      const results = await Promise.allSettled([
        fetchUsersZustand().then(data => setUsers(data)),
        fetchReservationsZustand().then(data => setReservations(data)),
        fetchFinancesZustand().then(data => setFinances(data)),
        fetchPackagesZustand().then(data => setPackages(data)),
        fetchCategoriesZustand().then(data => setCategories(data)),
        fetchExtrasZustand().then(data => setExtras(data)),
        fetchFoodOptionsZustand().then(data => setFoodOptions(data)),
        fetchThemesZustand().then(data => setTematicas(data)),
        fetchMamparasZustand().then(data => setMamparas(data)),
        fetchPaymentsZustand().then(data => setPayments(data)),
        // Obtener elementos archivados - todavÃ­a usando axios ya que no tenemos tiendas para estos
        axiosInstance.get('/reservas/archived'),
        axiosInstance.get('/pagos/archived'),
        axiosInstance.get('/finanzas/archived')
      ]);

      // Manejar elementos archivados
      const archivedData = [];
      if (results[10].status === 'fulfilled') {
        archivedData.push(...results[10].value.data.map(item => ({ ...item, type: 'reservas' })));
      }
      if (results[11].status === 'fulfilled') {
        archivedData.push(...results[11].value.data.map(item => ({ ...item, type: 'pagos' })));
      }
      if (results[12].status === 'fulfilled') {
        archivedData.push(...results[12].value.data.map(item => ({ ...item, type: 'finanzas' })));
      }
      setArchivedItems(archivedData);

      // Reportar errores
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          console.error(`Error en la solicitud ${index}:`, result.reason);
          
          // No mostrar toast para errores 404 en solicitudes de elementos archivados (Ã­ndices 10, 11, 12)
          const isArchivedRequest = index >= 10 && index <= 12;
          const is404Error = result.reason?.response?.status === 404;
          
          if (!(isArchivedRequest && is404Error)) {
            toast.error(`Error al cargar los datos de la solicitud ${index + 1}`);
          }
        }
      });
    } catch (error) {
      console.error('Error al cargar los datos:', error);
      toast.error('Error al cargar los datos');
    } finally {
      setLoading(false);
    }
  }, [
    fetchUsersZustand, fetchReservationsZustand, fetchFinancesZustand, 
    fetchPackagesZustand, fetchCategoriesZustand, fetchExtrasZustand, 
    fetchFoodOptionsZustand, fetchThemesZustand, fetchMamparasZustand, 
    fetchPaymentsZustand, setLoading
  ]);

  useEffect(() => {
    // Inicializar datos y configurar Socket.IO
    fetchData().then(() => {
      // Usar la funciÃ³n initSocketListeners de reservationsStore para centralizar la lÃ³gica de sockets
      // Esta funciÃ³n se encarga de inicializar Socket.IO y configurar todos los listeners
      // TambiÃ©n actualiza automÃ¡ticamente el estado global de reservations en la tienda
      initSocketListeners({
        onReservaCreada: (nuevaReserva) => {
          console.log('Reserva creada recibida vÃ­a Socket.IO:', nuevaReserva);
          toast.success(`Nueva reserva #${nuevaReserva.id} creada`);
        },
        onReservaActualizada: (reservaActualizada) => {
          console.log('Reserva actualizada recibida vÃ­a Socket.IO:', reservaActualizada);
        },
        onReservaEliminada: (data) => {
          console.log('Reserva eliminada recibida vÃ­a Socket.IO:', data);
        },
        onFechasBloqueadas: (data) => {
          console.log('Fechas bloqueadas recibidas vÃ­a Socket.IO:', data);
          if (!data.reservas || !Array.isArray(data.reservas)) {
            // Si no tenemos datos completos de las reservas, recargar todo
            fetchData();
          }
        },
        onError: (error) => {
          console.error('Error en Socket.IO:', error);
          toast.error('Error en la comunicaciÃ³n en tiempo real');
        }
      });
    });

    // Limpieza al desmontar el componente
    return () => {
      // Desconectar y limpiar Socket.IO
      socketService.disconnect();
      // Limpiar listeners de Socket.IO
      useReservationsStore.getState().cleanupSocketListeners();
    };
  }, [fetchData, initSocketListeners]);

  const filteredUsers = useMemo(() => {
    return users.filter(
      user =>
        user.nombre.toLowerCase().includes(userSearch.toLowerCase()) ||
        user.email.toLowerCase().includes(userSearch.toLowerCase()) ||
        (user.id_personalizado &&
          user.id_personalizado
            .toLowerCase()
            .includes(userSearch.toLowerCase()))
    )
  }, [users, userSearch])

  const filteredReservations = useMemo(() => {
    return reservations.filter(
      reservation =>
        reservation.id.toString().includes(reservationSearch) ||
        (reservation.nombre_festejado &&
          reservation.nombre_festejado
            .toLowerCase()
            .includes(reservationSearch.toLowerCase()))
    )
  }, [reservations, reservationSearch])

  useEffect(() => {
    const checkScreenSize = () => {
      setIsSmallScreen(window.innerWidth < 768)
    }

    checkScreenSize()
    window.addEventListener('resize', checkScreenSize)

    return () => window.removeEventListener('resize', checkScreenSize)
  }, [])

  const handleViewReservation = useCallback(reservation => {
    setSelectedReservation(reservation)
    setIsReservationModalOpen(true)
  }, [])

  // FunciÃ³n para filtrar datos por mes
  const filterDataByMonth = useCallback(
    (data, dateField) => {
      // Primero verificar si data es un array
      if (!Array.isArray(data)) return [];
      
      // Filtrar por mes
      return data.filter(item => {
        // Verificar que el item y el campo de fecha existen
        if (!item || !item[dateField]) return false;
        
        // Convertir a objeto Date
        const itemDate = new Date(item[dateField]);
        
        // Asegurarse de que la fecha es vÃ¡lida
        if (isNaN(itemDate.getTime())) return false;
        
        // Comparar tanto mes como aÃ±o
        return itemDate.getMonth() === selectedMonth && 
               itemDate.getFullYear() === selectedYear;
      });
    },
    [selectedMonth, selectedYear]
  );

  const handleAddItem = useCallback(() => {
    if (activeTab === 'payments') {
      setSelectedPayment(null)
      setPaymentModalMode('add')
      setIsPaymentModalOpen(true)
    } else {
      setEditingItem(null)
      setIsModalOpen(true)
    }
  }, [activeTab])

  const handleSavePayment = useCallback(async (paymentData) => {
    try {
      await usePaymentsStore.getState().addPayment(paymentData);
      setIsPaymentModalOpen(false);
      fetchData();
    } catch (error) {
      console.error('Error al crear el pago:', error);
      toast.error('Error al crear el pago');
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData, setIsPaymentModalOpen])

  const handleEditItem = useCallback(
    item => {
      console.log('Editando elemento:', item)
      if (activeTab === 'payments') {
        setSelectedPayment(item)
        setPaymentModalMode('add')
        setIsPaymentModalOpen(true)
      } else {
        setEditingItem(item)
        setIsModalOpen(true)
      }
    },
    [activeTab]
  )
  
  const handleUpdatePaymentStatus = useCallback(async (paymentId, newStatus) => {
    try {
      await usePaymentsStore.getState().updatePaymentStatus(paymentId, newStatus);
      // Actualizar la UI con datos frescos
      await fetchData();
    } catch (error) {
      console.error('Error al actualizar el estado del pago:', error);
      toast.error('Error al actualizar el estado del pago');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData])

  const handleReservationStatusChange = useCallback(async (reservationId, newStatus) => {
    try {
      // Usar la tienda Zustand para actualizar el estado de la reserva
      await useReservationsStore.getState().updateReservationStatus(reservationId, newStatus);
      // No es necesario actualizar manualmente el estado local, ya que se actualizarÃ¡
      // automÃ¡ticamente desde la tienda al llamar a updateReservationStatus
      toast.success('Estado de la reserva actualizado con Ã©xito');
    } catch (error) {
      console.error('Error al actualizar el estado de la reserva:', error);
      toast.error('Error al actualizar el estado de la reserva');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate])

  const handleSendEmail = useCallback(reservation => {
    toast.info(`Funcionalidad de enviar correo a ${reservation.usuario.email}`)
  }, [])

  const handleContactUser = useCallback(reservation => {
    toast.info(
      `Funcionalidad de contactar al usuario ${reservation.usuario.nombre}`
    )
  }, [])

  const handleError = useCallback(
    (error, action) => {
      if (error.response) {
        if (error.response.status === 404) {
          toast.warning('El elemento ya no existe')
        } else if (error.response.status === 401) {
          toast.error(
            'Tu sesiÃ³n ha expirado. Por favor, inicia sesiÃ³n nuevamente.'
          )
          navigate('/signin')
        } else {
          toast.error(
            `Error del servidor al ${action} el elemento: ${
              error.response.data.message || 'Algo saliÃ³ mal'
            }`
          )
        }
      } else if (error.request) {
        toast.error('No se recibiÃ³ respuesta del servidor')
      } else {
        toast.error(`Error al ${action} el elemento`)
      }
      console.error(`Error al ${action} el elemento:`, error)
    },
    [navigate]
  )

  function removeCircularReferences (obj, seen = new WeakSet()) {
    if (typeof obj !== 'object' || obj === null) {
      return obj
    }
    if (seen.has(obj)) {
      return '[Circular]'
    }
    seen.add(obj)
    const newObj = Array.isArray(obj) ? [] : {}
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = removeCircularReferences(obj[key], seen)
      }
    }
    return newObj
  }

  const handleSubmit = useCallback(
    async data => {
      setLoading(true)
      try {
        console.log('Datos recibidos en handleSubmit:', data)
        
        // Limpiar y validar los datos
        const cleanedData = removeCircularReferences(data)
        console.log('Datos limpios a enviar al servidor:', cleanedData)
        
        // Para reservas, validar y asegurar que id_usuario sea un nÃºmero
        if (activeTab === 'reservations' && !cleanedData.id_usuario) {
          toast.error('Debe seleccionar un usuario para la reserva')
          setLoading(false)
          return
        }
        
        if (activeTab === 'reservations') {
          cleanedData.id_usuario = Number(cleanedData.id_usuario)
        }
        
        // Usar las tiendas Zustand para crear/actualizar
        let result;
        
        if (editingItem) {
          // Actualizar usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().updateUser(editingItem.id, cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().updateReservation(editingItem.id, cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().updateFinance(editingItem.id, cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().updatePackage(editingItem.id, cleanedData);
              break;
            case 'extras':
              result = await useExtrasStore.getState().updateExtra(editingItem.id, cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().updateFoodOption(editingItem.id, cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().updateTheme(editingItem.id, cleanedData);
              break;
            case 'mamparas':
              result = await useMamparasStore.getState().updateMampara(editingItem.id, cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().updatePayment(editingItem.id, cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        } else {
          // Crear usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().addUser(cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().addReservation(cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().addFinance(cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().addPackage(cleanedData);
              break;
            case 'extras':
              result = await useExtrasStore.getState().addExtra(cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().addFoodOption(cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().addTheme(cleanedData);
              break;
            case 'mamparas':
              result = await useMamparasStore.getState().addMampara(cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().addPayment(cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        }
        
        setIsModalOpen(false);
        // Actualizar la UI con datos frescos
        await fetchData();
        
      } catch (error) {
        console.error('Error en handleSubmit:', error)
        if (error.response && error.response.status === 401) {
          toast.error(
            'Tu sesiÃ³n ha expirado. Por favor, inicia sesiÃ³n nuevamente.'
          )
          navigate('/signin')
          return
        } else {
          handleError(error, editingItem ? 'actualizar' : 'crear')
        }
      } finally {
        setLoading(false)
      }
    },
    [activeTab, editingItem, fetchData, handleError, navigate, setLoading, setIsModalOpen]
  )

  const handleDeleteItem = async (endpoint, id, successMessage) => {
    const result = await Swal.fire({
      title: 'Â¿EstÃ¡s seguro?',
      text: 'Esta acciÃ³n desactivarÃ¡ el registro. PodrÃ¡s reactivarlo mÃ¡s tarde si es necesario.',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'SÃ­, desactivar',
      cancelButtonText: 'Cancelar'
    })

    if (result.isConfirmed) {
      try {
        // Determinar quÃ© tienda usar basado en el endpoint
        switch (endpoint) {
          case '/api/usuarios':
            await useUsersStore.getState().deleteUser(id);
            break;
          case '/api/reservas':
            await useReservationsStore.getState().deleteReservation(id);
            break;
          case '/api/finanzas':
            await useFinancesStore.getState().deleteFinance(id);
            break;
          case '/api/paquetes':
            await usePackagesStore.getState().deletePackage(id);
            break;
          case '/api/extras':
            await useExtrasStore.getState().deleteExtra(id);
            break;
          case '/api/opciones-alimentos':
            await useFoodOptionsStore.getState().deleteFoodOption(id);
            break;
          case '/api/tematicas':
            await useThemesStore.getState().deleteTheme(id);
            break;
          case '/api/mamparas':
            await useMamparasStore.getState().deleteMampara(id);
            break;
          case '/api/pagos':
            await usePaymentsStore.getState().deletePayment(id);
            break;
          default:
            // Si no hay una tienda especÃ­fica para el endpoint, usar axios directamente
            await axiosInstance.delete(`${endpoint}/${id}`);
        }
        
        Swal.fire('Â¡Desactivado!', successMessage, 'success');
        // Actualizar la UI con datos frescos
        await fetchData();
      } catch (error) {
        handleError(error, 'desactivar');
      }
    }
  }

  // Eliminada la funciÃ³n local generateRandomPassword ya que la estamos importando desde useUiStore

  const handleDownloadFile = useCallback(async (id, type) => {
    try {
      // Usar la tienda Zustand para descargar el archivo
      const blob = await useFinancesStore.getState().downloadFinanceFile(id, type);
      
      // Crear URL para el blob y descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `finanza_${id}_${type}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
      
      // Liberar la URL
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error al descargar el archivo:', error);
      toast.error('Error al descargar el archivo');
    }
  }, [])

  const handleViewDetails = useCallback(finance => {
    setSelectedFinance(finance)
  }, [])

  const handleAddCategory = useCallback(async newCategory => {
    try {
      await useCategoriesStore.getState().addCategory({
        nombre: newCategory.nombre,
        color: newCategory.color || '#000000'
      });
      // Actualizar categorÃ­as tras la adiciÃ³n
      const updatedCategories = await fetchCategoriesZustand();
      setCategories(updatedCategories);
      toast.success('CategorÃ­a aÃ±adida con Ã©xito');
    } catch (error) {
      console.error('Error al aÃ±adir la categorÃ­a:', error);
      toast.error('Error al aÃ±adir la categorÃ­a');
    }
  }, [fetchCategoriesZustand])

  const renderModalContent = useCallback(() => {
    const props = {
      editingItem,
      onSave: handleSubmit,
      generateRandomPassword,
      generatedPassword,
      users,
      packages,
      categories,
      onAddCategory: handleAddCategory,
      reservations,
      tematicas,
      foodOptions,
      extras,
      currentUser
    }
    switch (activeTab) {
      case 'users':
        return <UserForm {...props} />
      case 'reservations':
        return <ReservationForm {...props} />
      case 'finances':
        return <FinanceForm {...props} />
      case 'packages':
        return <PackageForm {...props} />
      case 'extras':
        return <ExtraForm {...props} />
      case 'opcionesAlimento':
        return <OpcionAlimentoForm {...props} />
      case 'tematicas':
        return <TematicaForm {...props} />
      case 'mamparas':
        return <MamparaForm {...props} />
      case 'payments':
        return <PaymentForm {...props} />
      default:
        return null
    }
  }, [
    activeTab,
    editingItem,
    handleSubmit,
    generateRandomPassword,
    generatedPassword,
    users,
    packages,
    categories,
    handleAddCategory,
    reservations,
    tematicas,
    foodOptions,
    extras
  ])

  
  // Renderizar componente del panel segÃºn la categorÃ­a activa
  const renderDashboardWidgets = () => {
    if (!isMainDashboard) return null;
    
    return (
      <div className='mb-8'>
        {/* Header del Dashboard con gradiente */}
        <div className="bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl shadow-lg p-6 mb-8">
          <h1 className="text-3xl font-bold text-white mb-2">Panel de Control</h1>
          <p className="text-indigo-100">Bienvenido al sistema de administraciÃ³n de Tramboory</p>
        </div>
        
        {/* Widgets de estadÃ­sticas */}
        <div className='grid grid-cols-1 md:grid-cols-3 gap-6 mb-8'>
          <div className="bg-gradient-to-br from-indigo-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <UserSummary users={users} />
          </div>
          <div className="bg-gradient-to-br from-green-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-green-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <ReservationSummary
              reservations={reservations}
              filterDataByMonth={filterDataByMonth}
            />
          </div>
          <div className="bg-gradient-to-br from-purple-50 to-white p-0 rounded-xl shadow-md overflow-hidden border border-purple-100 transform transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-2xl font-semibold text-gray-800">Pagos</h2>
                <div className="p-2 rounded-full bg-purple-100 text-purple-600">
                  <HiPlus className="w-5 h-5" />
                </div>
              </div>
              <p className="text-4xl font-bold text-purple-600">{payments.length}</p>
              <p className="text-sm text-gray-500 mt-1">
                {payments.filter(p => p.estado === 'completado').length} completados
              </p>
            </div>
          </div>
        </div>
        
        {/* Widgets principales */}
        <div className='grid grid-cols-1 lg:grid-cols-3 gap-6'>
          <div className="lg:col-span-2 bg-white rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-lg">
            <ReservationCalendar
              reservations={reservations}
              onSelectReservation={handleSelectReservation}
            />
          </div>
          <div className="bg-white rounded-xl shadow-md overflow-hidden border border-indigo-100 transform transition-all duration-300 hover:shadow-lg">
            <FinancialSummary
              finances={finances}
              filterDataByMonth={filterDataByMonth}
              categories={categories}
            />
          </div>
        </div>
      </div>
    );
  };
  
  // BotÃ³n de acciÃ³n contextual segÃºn la pestaÃ±a activa
  const renderActionButton = () => {
    // No mostrar botÃ³n en el dashboard principal
    if (isMainDashboard) return null;
    
    return (
      <div className="flex justify-end mb-4">
        <button
          onClick={handleAddItem}
          className="flex items-center px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors"
        >
          <HiPlus className="mr-2" />
          Agregar {getActiveTabLabel()}
        </button>
      </div>
    );
  };
  
  // Obtener nombre amigable para la pestaÃ±a activa
  const getActiveTabLabel = () => {
    switch (activeTab) {
      case 'users': return 'Usuario';
      case 'reservations': return 'ReservaciÃ³n';
      case 'finances': return 'Registro';
      case 'payments': return 'Pago';
      case 'packages': return 'Paquete';
      case 'extras': return 'Extra';
      case 'opcionesAlimento': return 'OpciÃ³n de Alimento';
      case 'tematicas': return 'TemÃ¡tica';
      case 'mamparas': return 'Mampara';
      case 'galeria': return 'Imagen';
      default: return 'Elemento';
    }
  };
  
  return (
    <CrmLayout>
      {isSmallScreen && showAlert && (
        <ScreenSizeAlert setShowAlert={setShowAlert} />
      )}
      
      {/* Widgets del dashboard principal, solo se muestran en la vista de dashboard */}
      {renderDashboardWidgets()}
      
      {/* Contenedor principal contextual */}
      <div className='bg-white rounded-xl shadow-md p-6 border border-gray-100'>
        {/* Breadcrumb para navegaciÃ³n contextual */}
        <Breadcrumb 
          items={currentBreadcrumbItems} 
          onNavigate={handleBreadcrumbNavigation}
        />
        
        {/* BotÃ³n de acciÃ³n contextual */}
        {renderActionButton()}
        {/* Contenido segÃºn pestaÃ±a activa */}
        {activeTab === 'users' && (
          <UserTable
            users={filteredUsers}
            userSearch={userSearch}
            setUserSearch={setUserSearch}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/usuarios',
                id,
                'Usuario desactivado con Ã©xito',
                () => setIsModalOpen(false)
              )
            }
            handleViewUser={handleViewUser}
          />
        )}
        {activeTab === 'reservations' && (
          <ReservationTable
            reservations={filterDataByMonth(reservations, 'fecha_reserva')}
            reservationSearch={reservationSearch}
            setReservationSearch={setReservationSearch}
            handleViewReservation={handleViewReservation}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/reservas',
                id,
                'Reserva desactivada con Ã©xito'
              )
            }
            selectedMonth={selectedMonth}
          />
        )}
        {activeTab === 'finances' && (
          <FinanceTable
            finances={filterDataByMonth(finances, 'fecha')}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/finanzas',
                id,
                'Finanza desactivada con Ã©xito',
                () => setIsModalOpen(false)
              )
            }
            handleDownloadFile={handleDownloadFile}
            handleViewDetails={handleViewDetails}
            categories={categories}
            generateMonthlyReport={generateMonthlyReport}
          />
        )}
        {activeTab === 'packages' && (
          <PackageTable
            packages={packages}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/paquetes',
                id,
                'Paquete desactivado con Ã©xito',
                () => setIsModalOpen(false),
                'paquetes'
              )
            }
          />
        )}
        {activeTab === 'extras' && (
          <ExtraTable
            extras={extras}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem('/api/extras', id, 'Extra eliminado con Ã©xito')
            }
          />
        )}
        {activeTab === 'opcionesAlimento' && (
          <OpcionAlimentoTable
            opcionesAlimento={foodOptions}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/opciones-alimentos',
                id,
                'OpciÃ³n de alimento eliminada con Ã©xito'
              )
            }
          />
        )}
        {activeTab === 'tematicas' && (
          <TematicaTable
            tematicas={tematicas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/tematicas',
                id,
                'TemÃ¡tica eliminada con Ã©xito'
              )
            }
          />
        )}
        {activeTab === 'mamparas' && (
          <MamparaTable
            tematicas={tematicas}
            mamparas={mamparas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/mamparas',
                id,
                'Mampara eliminada con Ã©xito'
              )
            }
          />
        )}
        {activeTab === 'payments' && (
          <PaymentTable
            payments={payments}
            reservations={reservations}
            onViewPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('view')
              setIsPaymentModalOpen(true)
            }}
            onEditPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('edit')
              setIsPaymentModalOpen(true)
            }}
          />
        )}
        {activeTab === 'auditoria' && (
          <AuditHistory />
        )}
        {activeTab === 'archived' && (
          <ArchivedTable
            items={archivedItems}
            itemSearch={archivedSearch}
            setItemSearch={setArchivedSearch}
            fetchData={fetchData}
            selectedMonth={selectedMonth}
            type="reservas"
          />
        )}
        {activeTab === 'galeria' && (
          <GaleriaManagement />
        )}
      </div>
      <MonthSelector
        selectedMonth={selectedMonth}
        setSelectedMonth={setSelectedMonth}
        selectedYear={selectedYear}
        setSelectedYear={setSelectedYear}
      />
      {isReservationModalOpen && selectedReservation && (
        <ReservationModal
          reservation={selectedReservation}
          onClose={handleCloseReservationModal}
          onStatusChange={newStatus =>
            handleReservationStatusChange(selectedReservation.id, newStatus)
          }
          onSendEmail={handleSendEmail}
          onContactUser={handleContactUser}
          tematicas={tematicas}
          extras={extras}
        />
      )}
      {isModalOpen && (
        <ItemModal
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          title={`${editingItem ? 'Editar' : 'Agregar'} ${activeTab.slice(
            0,
            -1
          )}`}
          loading={loading}
          activeTab={activeTab}
          handleSubmit={handleSubmit}
          editingItem={editingItem}
          generatedPassword={generatedPassword}
          generateRandomPassword={generateRandomPassword}
          users={users}
          packages={packages}
          reservations={reservations}
          categories={categories}
          onAddCategory={handleAddCategory}
          tematicas={tematicas}
          foodOptions={foodOptions}
          extras={extras}
          mamparas={mamparas}
          currentUser={currentUser}
        />
      )}
      {selectedFinance && (
        <FinanceDetailModal
          finance={selectedFinance}
          onClose={() => setSelectedFinance(null)}
          onDownloadFile={handleDownloadFile}
        />
      )}
      {isPaymentModalOpen && (
        <PaymentModal
          payment={selectedPayment}
          isOpen={isPaymentModalOpen}
          onClose={() => {
            setSelectedPayment(null)
            setIsPaymentModalOpen(false)
          }}
          onUpdateStatus={handleUpdatePaymentStatus}
          onSavePayment={handleSavePayment}
          reservations={reservations}
          mode={paymentModalMode}
        />
      )}
      {isUserModalOpen && selectedUser && (
        <UserModal
          user={selectedUser}
          reservations={reservations.filter(res => res.id_usuario === selectedUser.id)}
          onClose={() => {
            setSelectedUser(null)
            setIsUserModalOpen(false)
          }}
          onEdit={handleEditItem}
          onSendEmail={() => toast.info(`Funcionalidad de enviar correo a ${selectedUser.email}`)}
        />
      )}
      {isReportModalOpen && (
        <MonthlyReportModal
          isOpen={isReportModalOpen}
          onClose={() => setIsReportModalOpen(false)}
          finances={finances}
          categories={categories}
          selectedMonth={selectedMonth}
          selectedYear={selectedYear}
        />
      )}
    </CrmLayout>
  )
}

export default Dashboard\n\n

=== ./dashboard/pages/index.js ===
ï»¿export { default as Dashboard } from './Dashboard';
\n\n


